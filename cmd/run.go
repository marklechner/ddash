package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"strings"
	"syscall"
)

const runUsage = `Run a command inside a macOS sandbox

Usage:
  ddash run [flags] -- <command> [args...]

Wraps any command with a kernel-level sandbox profile. By default,
the sandbox denies network access, restricts filesystem writes
to the current directory, and scrubs sensitive environment variables.

If a .ddash.json config exists, its policy is applied automatically.

Default policy:
  Network:    denied
  Reads:      system paths + current directory
  Writes:     current directory + /tmp
  Env vars:   sensitive variables stripped (tokens, keys, secrets)
  Processes:  allowed

Examples:
  ddash run -- ./build.sh                Run with no network, env scrubbed
  ddash run -- python train.py           Sandbox a Python script
  ddash run --allow-net -- npm install    Allow network for installs
  ddash run --net -- npm install          Interactive per-domain network control
  ddash run --deny-write -- ./analyze     Full read-only sandbox
  ddash run --pass-env -- ./needs-creds   Pass all env vars through
  ddash run --profile -- node app.js      Print profile without running

Flags:
  --allow-net       Allow all network access (overrides config)
  --net             Interactive network: prompt per domain (like Little Snitch)
  --deny-write      Deny all filesystem writes (overrides config)
  --pass-env        Pass all environment variables (disables scrubbing)
  --profile         Print the generated sandbox profile and exit
  -h, --help        Show help`

// Env vars matching these prefixes or exact names are stripped by default.
// These cover common secret patterns across cloud providers, CI systems,
// package managers, and developer tools.
var sensitiveEnvPrefixes = []string{
	"AWS_",
	"AZURE_",
	"GCP_",
	"GOOGLE_",
	"GITHUB_TOKEN",
	"GH_TOKEN",
	"GITLAB_",
	"NPM_TOKEN",
	"PYPI_TOKEN",
	"DOCKER_",
	"HOMEBREW_GITHUB_API_TOKEN",
	"SNYK_TOKEN",
	"SENTRY_",
	"DATADOG_",
	"DD_",
	"SLACK_TOKEN",
	"SLACK_WEBHOOK",
	"TWILIO_",
	"SENDGRID_",
	"STRIPE_",
	"DATABASE_URL",
	"REDIS_URL",
	"MONGO",
	"OPENAI_API",
	"ANTHROPIC_API",
	"HF_TOKEN",
	"HUGGING",
}

var sensitiveEnvSubstrings = []string{
	"_SECRET",
	"_TOKEN",
	"_KEY",
	"_PASSWORD",
	"_CREDENTIAL",
	"_AUTH",
}

type runFlags struct {
	allowNet       bool
	interactiveNet bool
	denyWrite      bool
	passEnv        bool
	printOnly      bool
}

func runCmd() error {
	if len(os.Args) < 3 {
		fmt.Println(runUsage)
		return nil
	}

	flags := runFlags{}
	cmdStart := -1

	for i := 2; i < len(os.Args); i++ {
		switch os.Args[i] {
		case "--allow-net":
			flags.allowNet = true
		case "--net":
			flags.interactiveNet = true
		case "--deny-write":
			flags.denyWrite = true
		case "--pass-env":
			flags.passEnv = true
		case "--profile":
			flags.printOnly = true
		case "-h", "--help":
			fmt.Println(runUsage)
			return nil
		case "--":
			if i+1 < len(os.Args) {
				cmdStart = i + 1
			}
		default:
			if cmdStart == -1 {
				return fmt.Errorf("unknown flag: %s\nUse -- before the command, e.g.: ddash run -- %s", os.Args[i], os.Args[i])
			}
		}
		if cmdStart != -1 {
			break
		}
	}

	if cmdStart == -1 {
		fmt.Println(runUsage)
		return fmt.Errorf("no command specified; use -- before the command")
	}

	if flags.allowNet && flags.interactiveNet {
		return fmt.Errorf("--allow-net and --net are mutually exclusive")
	}

	cfg := loadRunConfig()

	// CLI flags override config
	if flags.allowNet {
		cfg.AllowNet = []string{"*"}
	}
	if flags.denyWrite {
		cfg.AllowWrite = []string{}
	}

	profile := generateProfile(cfg, flags.denyWrite, flags.interactiveNet)

	if flags.printOnly {
		fmt.Println(profile)
		return nil
	}

	return execSandboxed(profile, os.Args[cmdStart:], flags, cfg)
}

func loadRunConfig() SandboxConfig {
	data, err := os.ReadFile(configPath())
	if err != nil {
		// Default restrictive config
		return SandboxConfig{
			Name:       "default",
			Isolation:  "process",
			AllowNet:   []string{},
			AllowRead:  []string{"."},
			AllowWrite: []string{"."},
		}
	}

	var cfg SandboxConfig
	if err := json.Unmarshal(data, &cfg); err != nil {
		return SandboxConfig{
			Name:       "default",
			Isolation:  "process",
			AllowNet:   []string{},
			AllowRead:  []string{"."},
			AllowWrite: []string{"."},
		}
	}

	// Ensure AllowWrite has a default
	if cfg.AllowWrite == nil {
		cfg.AllowWrite = []string{"."}
	}

	return cfg
}

func generateProfile(cfg SandboxConfig, denyAllWrites bool, proxyMode bool) string {
	var sb strings.Builder

	sb.WriteString(";; Generated by ddash " + Version + "\n")
	sb.WriteString("(version 1)\n")
	sb.WriteString("(deny default)\n\n")

	// Always allow basic process execution
	sb.WriteString(";; Allow process execution\n")
	sb.WriteString("(allow process-exec)\n")
	sb.WriteString("(allow process-fork)\n")
	sb.WriteString("(allow process-info*)\n\n")

	// Allow sysctl reads (required by most programs)
	sb.WriteString(";; System basics\n")
	sb.WriteString("(allow sysctl-read)\n")
	sb.WriteString("(allow mach-lookup)\n")
	sb.WriteString("(allow signal)\n")
	sb.WriteString("(allow iokit-open)\n\n")

	// File reads
	sb.WriteString(";; File read access\n")
	// Always allow reading system libraries and common paths
	sb.WriteString("(allow file-read* (subpath \"/bin\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/sbin\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/usr\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/System\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/Library\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/opt/homebrew\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/private/etc\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/private/tmp\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/private/var\"))\n")
	sb.WriteString("(allow file-read* (subpath \"/dev\"))\n")
	sb.WriteString("(allow file-read* (literal \"/\"))\n")
	sb.WriteString("(allow file-read-metadata)\n")

	cwd, _ := os.Getwd()
	for _, path := range cfg.AllowRead {
		resolved := resolvePath(path, cwd)
		sb.WriteString(fmt.Sprintf("(allow file-read* (subpath \"%s\"))\n", resolved))
	}
	sb.WriteString("\n")

	// File writes
	sb.WriteString(";; File write access\n")
	if denyAllWrites {
		sb.WriteString(";; All writes denied (--deny-write)\n")
		sb.WriteString("(allow file-write* (subpath \"/dev/null\"))\n")
	} else {
		sb.WriteString("(allow file-write* (subpath \"/private/tmp\"))\n")
		sb.WriteString("(allow file-write* (subpath \"/dev\"))\n")
		for _, path := range cfg.AllowWrite {
			resolved := resolvePath(path, cwd)
			sb.WriteString(fmt.Sprintf("(allow file-write* (subpath \"%s\"))\n", resolved))
		}
	}
	sb.WriteString("\n")

	// Network
	sb.WriteString(";; Network access\n")
	if proxyMode {
		// In proxy mode, allow connections only to the local proxy (127.0.0.1).
		// All external connections go through the proxy which prompts the user.
		sb.WriteString(";; Interactive proxy mode — only localhost allowed\n")
		sb.WriteString("(allow network* (remote ip \"localhost:*\"))\n")
	} else if len(cfg.AllowNet) > 0 {
		for _, n := range cfg.AllowNet {
			if n == "*" {
				sb.WriteString("(allow network*)\n")
				break
			}
			sb.WriteString(fmt.Sprintf(";; allow: %s\n", n))
		}
	} else {
		sb.WriteString(";; Network denied (default)\n")
	}

	return sb.String()
}

func resolvePath(path, cwd string) string {
	if path == "." {
		return cwd
	}
	if strings.HasPrefix(path, "/") {
		return path
	}
	return cwd + "/" + path
}

func scrubEnv() []string {
	var clean []string
	var stripped []string

	for _, env := range os.Environ() {
		name := env
		if idx := strings.Index(env, "="); idx >= 0 {
			name = env[:idx]
		}

		if isSensitive(name) {
			stripped = append(stripped, name)
			continue
		}
		clean = append(clean, env)
	}

	if len(stripped) > 0 {
		fmt.Fprintf(os.Stderr, "ddash: scrubbed %d env var(s): %s\n",
			len(stripped), strings.Join(stripped, ", "))
	}

	return clean
}

func isSensitive(name string) bool {
	upper := strings.ToUpper(name)

	for _, prefix := range sensitiveEnvPrefixes {
		if strings.HasPrefix(upper, prefix) {
			return true
		}
	}

	for _, substr := range sensitiveEnvSubstrings {
		if strings.Contains(upper, substr) {
			return true
		}
	}

	return false
}

func execSandboxed(profile string, args []string, flags runFlags, cfg SandboxConfig) error {
	// Find the command binary
	binary, err := exec.LookPath(args[0])
	if err != nil {
		return fmt.Errorf("command not found: %s", args[0])
	}

	sandboxExec, err := exec.LookPath("sandbox-exec")
	if err != nil {
		return fmt.Errorf("sandbox-exec not found — ddash requires macOS sandbox support")
	}

	// Build environment
	var env []string
	if flags.passEnv {
		env = os.Environ()
	} else {
		env = scrubEnv()
	}

	// Start interactive proxy if --net
	var proxy *NetworkProxy
	if flags.interactiveNet {
		domains := cfg.NetworkDomains
		if domains == nil {
			domains = make(map[string]string)
		}
		proxy, err = NewProxy(domains, strings.Join(args, " "))
		if err != nil {
			return fmt.Errorf("failed to start network proxy: %w", err)
		}
		defer proxy.Shutdown()
		proxy.Start()

		proxyURL := "http://" + proxy.Addr()
		env = append(env,
			"HTTP_PROXY="+proxyURL,
			"HTTPS_PROXY="+proxyURL,
			"http_proxy="+proxyURL,
			"https_proxy="+proxyURL,
		)
	}

	envStatus := "scrubbed"
	if flags.passEnv {
		envStatus = "passed"
	}
	netStatus := networkStatus(profile)
	if flags.interactiveNet {
		netStatus = "interactive"
	}

	fmt.Fprintf(os.Stderr, "ddash: sandboxing %s (network=%s, writes=%s, env=%s)\n",
		args[0], netStatus, writeStatus(profile), envStatus)

	// Build sandbox-exec command args
	cmdArgs := []string{"-p", profile, binary}
	cmdArgs = append(cmdArgs, args[1:]...)

	// Use exec.Command instead of syscall.Exec for proper stdin/stdout/stderr
	// piping. syscall.Exec replaces the process which breaks piped input.
	cmd := exec.Command(sandboxExec, cmdArgs...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = env

	// Forward signals to the child process
	sigCh := make(chan os.Signal, 1)
	signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)
	go func() {
		for sig := range sigCh {
			if cmd.Process != nil {
				cmd.Process.Signal(sig)
			}
		}
	}()
	defer signal.Stop(sigCh)

	runErr := cmd.Run()

	// After command exits, save any "always"/"never" domain decisions
	if proxy != nil {
		saveDomainDecisions(proxy.Domains(), cfg)
	}

	if runErr != nil {
		if exitErr, ok := runErr.(*exec.ExitError); ok {
			os.Exit(exitErr.ExitCode())
		}
		return runErr
	}

	return nil
}

// saveDomainDecisions persists "always"/"never" domain decisions to .ddash.json.
func saveDomainDecisions(domains map[string]string, cfg SandboxConfig) {
	// Collect only persistent decisions (always/never)
	persistent := make(map[string]string)
	for domain, decision := range domains {
		if decision == "always" || decision == "never" {
			persistent[domain] = decision
		}
	}

	if len(persistent) == 0 {
		return
	}

	// Merge with existing config
	if cfg.NetworkDomains == nil {
		cfg.NetworkDomains = make(map[string]string)
	}
	newCount := 0
	for domain, decision := range persistent {
		if cfg.NetworkDomains[domain] != decision {
			cfg.NetworkDomains[domain] = decision
			newCount++
		}
	}

	if newCount == 0 {
		return
	}

	data, err := json.MarshalIndent(cfg, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "ddash: failed to save domain rules: %v\n", err)
		return
	}

	if err := os.WriteFile(configPath(), append(data, '\n'), 0644); err != nil {
		fmt.Fprintf(os.Stderr, "ddash: failed to write config: %v\n", err)
		return
	}

	fmt.Fprintf(os.Stderr, "ddash: saved %d domain rule(s) to .ddash.json\n", newCount)
}

func networkStatus(profile string) string {
	if strings.Contains(profile, "(allow network*)") {
		return "allowed"
	}
	return "denied"
}

func writeStatus(profile string) string {
	if strings.Count(profile, "file-write*") <= 2 {
		return "restricted"
	}
	return "allowed"
}
